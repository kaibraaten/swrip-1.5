#!/usr/bin/env python

import sys
import re
import os
import datetime

if __name__ == '__main__':
    commands = []
    spells = []
    specfuns = []
    
    with open('src/mud.hpp') as f:
        for line in f:
            if line.startswith('DECLARE_CMD_FUN'):
                match = re.search('DECLARE_CMD_FUN\((.*)\)', line)
                commands.append(match.group(1))
            elif line.startswith('DECLARE_SPELL_FUN'):
                match = re.search('DECLARE_SPELL_FUN\((.*)\)', line)
                spells.append(match.group(1))
            elif line.startswith('DECLARE_SPEC_FUN'):
                match = re.search('DECLARE_SPEC_FUN\((.*)\)', line)
                specfuns.append(match.group(1))
                
    code = []
    code.append("""// Generated by {} on {}
// Do not edit this file. It will be overwritten when running the script.
""".format(os.path.basename(__file__), datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
    code.append("""#include <unordered_map>
#include <string>
#include "mud.hpp"

static std::unordered_map<std::string, std::function<void(std::shared_ptr<Character>, std::string)>> strToCmdFun = {
""")
    for line in commands:
        code.append('    { "' + line + '", ' + line + ' },\n')
    
    code.append("""};
static std::unordered_map<std::string, std::function<ch_ret(int, int, std::shared_ptr<Character>, const Vo&)>> strToSpellFun = {
""")
    for line in spells:
        code.append('    { "' + line + '", ' + line + ' },\n')

    code.append("""};    
static std::unordered_map<std::string, std::function<bool(std::shared_ptr<Character>)>> strToSpecFun = {
""")
    for line in specfuns:
        code.append('    { "' + line + '", ' + line + ' },\n')

    code.append("""};

std::function<void(std::shared_ptr<Character>, std::string)> GetSkillFunction(const std::string &name)
{
    const auto &i = strToCmdFun.find(name);

    if(i != strToCmdFun.end())
    {
        return i->second;
    }
    else
    {
        return skill_notfound;
    }
}

std::function<ch_ret(int, int, std::shared_ptr<Character>, const Vo&)> GetSpellFunction(const std::string &name)
{
    const auto &i = strToSpellFun.find(name);

    if(i != strToSpellFun.end())
    {
        return i->second;
    }
    else
    {
        return spell_notfound;
    }
}

std::function<bool(std::shared_ptr<Character>)> SpecialLookup(const std::string &name)
{
    const auto &i = strToSpecFun.find(name);

    if(i != strToSpecFun.end())
    {
        return (*i).second;
    }
    else
    {
        return nullptr;
    }
}

std::string LookupSpecial(std::function<bool(std::shared_ptr<Character>)> special)
{
    for(const auto &i : strToSpecFun)
    {
        const auto specptr = special.target<bool(*)(std::shared_ptr<Character>)>();
        const auto iptr = i.second.target<bool(*)(std::shared_ptr<Character>)>();

        if(specptr != nullptr && iptr != nullptr && *specptr == *iptr)
        {
            return i.first;
        }
    }

    return "";
}
""")

    if len(sys.argv) > 1:
        #print('Saving to file {}'.format(sys.argv[1]))
        with open(sys.argv[1], 'w') as f:
            for line in code:
                f.write(line)
    else:
        print(''.join(code))
